# Secret Contract Development Toolkit - SNIP52 (Private Push Notification) Interface

⚠️ This package is a sub-package of the `secret-toolkit` package. Please see its crate page for more context.

These functions are meant to help you easily create notification channels for private push notifications in secret contracts (see [SNIP-52 Private Push Notification](https://github.com/SolarRepublic/SNIPs/blob/feat/snip-52/SNIP-52.md)).

### Implementing a `DirectChannel` struct

Each notification channel will have a specified data format, which is defined by creating a struct that implements the `DirectChannel` trait, which has one method: `encode_cbor`. 

The following example illustrates how you might implement this for a channel called `my_channel` and notification data containing two fields: `sender` and `amount`.

```ignore
use cosmwasm_std::{Api, StdError, StdResult};
use secret_toolkit::notification::{EncoderExt, CBL_ARRAY_SHORT, CBL_BIGNUM_U64, CBL_U8, Notification, DirectChannel, GroupChannel};
use serde::{Deserialize, Serialize};
use minicbor_ser as cbor;

#[derive(Serialize, Debug, Deserialize, Clone)]
pub struct MyNotification {
    pub sender: Addr,
    pub amount: u128,
}

impl DirectChannel for MyNotification {
    const CHANNEL_ID: &'static str = "my_channel";
    const CDDL_SCHEMA: &'static str = "my_channel=[sender:bstr .size 20,amount:uint .size 8]";
    const ELEMENTS: u64 = 2;
    const PAYLOAD_SIZE: usize = CBL_ARRAY_SHORT + CBL_BIGNUM_U64 + CBL_U8;

    fn encode_cbor(&self, api: &dyn Api, encoder: &mut Encoder<&mut [u8]>) -> StdResult<()> {
        // amount:biguint (8-byte uint)
        encoder.ext_u64_from_u128(self.amount)?;

        // sender:bstr (20-byte address)
        let sender_raw = api.addr_canonicalize(sender.as_str())?;
        encoder.ext_address(sender_raw)?;

        Ok(())
    }
}
```


### Sending a TxHash notification

To send a notification to a recipient you first create a new `Notification` struct passing in the address of the recipient along with the notification data you want to send. Then to turn it into a `TxHashNotification` execute the `to_txhash_notification` method on the `Notification` by passing in `deps.api`, `env`, and an internal `secret`, which is a randomly generated byte slice that has been stored previously in your contract during initialization.

The following code snippet creates a notification for the above `my_channel` and adds it to the contract `Response` as a plaintext attribute.

```ignore
let notification = Notification::new(
    recipient,
    MyNotification {
        sender,
        1000_u128,
    }
)
.to_txhash_notification(deps.api, &env, secret)?;

// ... other code

// add notification to response
Ok(Response::new()
    .set_data(to_binary(&ExecuteAnswer::MyMessage { status: Success } )?)
    .add_attribute_plaintext(
        notification.id_plaintext(),
        notification.data_plaintext(),
    )
)
```

